[INCLUDE=presentation]
Title         : Program Verification with F*
Author        : Danek Ahman
Affiliation   : Inria Paris
Reveal Url    : ../reveal.js
Reveal Theme  : white
Colorizer     : ../../stuff/fstarlang
Logo          : False
Html Header   :
    <script src="../../stuff/script.js"></script>
    <link rel="stylesheet" href="../../stuff/style.css" id="custom_style">
Package       : xypic
~Pre,~Code: language=fstarlang

~ MathDefs
[INCLUDE=../../stuff/latex.tex]
~

# F\*'s Extensible Effect System<br/>and<br/>Metaprogramming in F\*  #

~Center
[![fstar-logo]](https://www.fstar-lang.org)

**[Danel Ahman, Inria Paris](https://danelahman.github.io/)**

[EUTypes Summer School](https://sites.google.com/view/2018eutypesschool/home/)

Ohrid, Macedonia, 12 August, 2018
~

[fstar-logo]: ../../stuff/fstar-new.png { width=200px }

<!-------------------------------------------------------------------------------->

## Schedule ##

* Friday: A Gentle Introduction to F\* (Purely Functional Programs)

* Yesterday: Verifying Stateful Programs in F\*

* Today: Monotonic State in F\*

* **Today: F\*'s Extensible Effect System and Metaprogramming in F\***

<!------------------------------------------------------------------------------>

## This talk ##

* **Monadic effects** in F\*

* **Verifying effectful programs extrinsically** (monadic reification)

* **Under the hood:** Weakest preconditions (and Dijkstra monads)

* **Tactics** and **Metaprogramming** as a user-defined, non-primitive effect

<!------------------------------------------------------------------------------>

## Monadic effects in F\*: Global State ##

<!-- Effects defined using monads from total functions -->
```
type st (mem:Type) (a:Type) = mem -> Tot (a * mem)
```

~Fragment
```
total reifiable new_effect {
  STATE_m (mem:Type) : a:Type -> Effect
 
  with (* functional representation of the global state effect *)
       repr   = st mem;

       (* standard monadic return and bind for the state monad *)
       return = fun (a:Type) (x:a) (m:mem) -> (x, m);
       
       bind   = fun (a b:Type) (f:st mem a) (g:a -> st mem b) (m:mem) ->
                let (z, m') = f m in
                g z m';

       (* standard get and put actions for the state monad *)
       get    = fun () (m:mem) -> (m, m);
       
       put    = fun (m:mem) _ -> ((), m)
}
```
```
total reifiable new_effect STATE = STATE_m heap
```
~

* {.fragment} this monadic definition is the **model** F\*  uses to verify stateful code
* {.fragment} state can be **primitively implemented** under the hood, **or not**, e.g., 
  - by ML references,
  - or by C stack+heap

<!------------------------------------------------------------------------------>

## Programming with effects, in direct style ##

* In F\*, the programmer writes:
  ```
  let incr () : STATE unit ...
    = let x = get() in
      put (x + 1);
      let y = get() in
      assert (y > x)
  ```

* {.fragment} Which is then made explicitly monadic via type and effect inference

  ```
  let incr () : STATE unit ...
    = STATE.bind (STATE.get ()) (fun x -> 
      STATE.bind (STATE.put (x + 1)) (fun _ ->
      STATE.bind (STATE.get ()) (fun y ->
      STATE.return (assert (y > x)))))
  ```

<!------------------------------------------------------------------------------>

## Monadic lifts in F*: State + Exceptions ##

```
let stexn a = nat -> Tot ((either a string) * nat))
```
~Fragment
```
new_effect {
  STEXN: a:Type -> Effect

  with (* functional representation of the sum of state and exceptions monads *)
       repr    = stexn;

       (* standard monadic return and bind *)
       return  = fun (a:Type) (x:a) s -> (Inl x, s);
       
       bind    = fun (a b:Type) (f:stexn a) (g:a -> stexn b) s0 ->
                    let (r,s1) = f s0 in
                    match r with
                    | Inl ret -> (Inl (g ret s1), s1)
                    | Inr m -> (Inr m, s1)

       (* action of raising excaptions *)
       raise   = fun (a:Type) (msg:string) s -> (Inr msg, s);
}
```
~
~Fragment
```
sub_effect STATE ~> STEXN {
  lift = fun (a:Type)
             (e:st nat a)                                      (* st computation *)
         ->
             fun s -> let (x,s') = e s in (Inl x, s')          (* stexn computation *)
}
```
~

<!------------------------------------------------------------------------------>

## Programming with multiple effects, in direct style

* Programmer writes:
  ```
  ( / ) : int -> x:int{x<>0} -> Tot int
    
  let divide_by (x:int) : STEXN unit ...
    = if x <> 0 then put (get () / x)
                else raise "Divide by zero"
  ```

* {.fragment}Elaborated to:
  ```
  let divide_by x
    = if x <> 0 then STATE_STEXN.lift (STATE.bind (STATE.get()) (fun n ->
                                       STATE.put (n / x)))
                else STEXN.raise "Divide by zero"
  ```

* {.fragment}F\* infers the least effect of each sub-term
    - automatically lifts computations to use the suitable effect
    - ensures that reasoning isn't needlessly polluted by unused effects

<!------------------------------------------------------------------------------>

## Under the hood ##

### Weakest preconditions (Dijkstra monads for free) ###

<!-- ### SMT encoding ### -->

<!------------------------------------------------------------------------------>

## Computation types indexed by predicate transformers ##

Pre- and postconditions are just syntactic sugar:
```
Pure t (pre : Type0) (post : t->Type0)
  = PURE t (fun k -> pre /\ forall y. post y ==> k y)       (* where k is the         *)
                                                            (* "logical" continuation *)
```
```
val factorial : x:int -> Pure int (requires (x >= 0))
                                  (ensures  (fun y -> y >= 0))
```
```
val factorial : x:int -> Pure (fun k -> x >= 0 /\ forall y. y >= 0 ==> k y)
```
~Fragment
Same for user-defined effects, like `STATE`:
```
ST t (pre : nat -> Type0) (post : nat -> t -> nat -> Type0) 
  = STATE t (fun n0 k -> pre n0 /\ forall x n1. post n0 x n1 ==> k x n1)
```
```
val incr : unit -> St unit (requires (fun n0 -> True))
                           (ensures  (fun n0 _ n1 -> n1 = n0 + 1))
```
```
val incr : unit -> STATE unit (fun n0 k -> k () (n0 + 1))
```
~

## Computing weakest preconditions, by example ##
```
let incr () = STATE.bind (STATE.get()) (fun x ->
              STATE.put (x + 1))
```
* {.fragment} By inferring type for `incr` against following interface:
  ```
  STATE.get : unit -> STATE nat (STATE.get_wp ())
  
  STATE.put : n:nat -> STATE unit (STATE.put_wp n)
  
  STATE.bind : STATE 'a 'wa ->
               (x:'a -> STATE 'b ('wb x)) ->
               STATE 'b (STATE.bind_wp 'wa 'wb)
  ```
... we compute the weakest precondition for `incr`
  ```
  val incr : unit -> STATE unit (STATE.bind_wp (STATE.get_wp()) (fun x ->
                                 STATE.put_wp (x + 1)))
  ```
  ```
                               = fun n0 k -> k () (n0 + 1)
  ```
* {.fragment} **Generic way of computing weakest-preconditions for all effects**
  - provided we have a monad structure on predicate transformers
  - instance of a more general notion of monad-indexed monad structures

## Predicate transformers monad for state ## 

### aka a Dijkstra monad for state ###

```
let STATE.wp t = (t -> nat -> Type0) -> (nat -> Type0)

val STATE.return_wp : 'a -> Tot (STATE.wp 'a)

val STATE.bind_wp : (STATE.wp 'a) ->
                    ('a -> Tot (STATE.wp 'b)) ->
                    Tot (STATE.wp 'b)
                      
val STATE.get_wp : unit -> Tot (STATE.wp nat)
val STATE.put_wp : nat -> Tot (STATE.wp unit)
```
* whose implementation is given by:
```
let STATE.return_wp v = fun p -> p v
let STATE.bind_wp wp f = fun p -> wp (fun v -> f v p)
let STATE.get_wp () = fun p n0 -> p n0 n0
let STATE.put_wp n = fun p _ -> p () n
```
* and for a while we wrote such things by hand;\

* but this is **quite tricky** and comes with **strong proof obligations**\
  (correctness with respect to effect definition, monad laws, ...)

## Dijkstra monads for free ## {#dm4f}

```
STATE.wp t  = (t -> nat -> Type0) -> (nat -> Type0)

           ~= nat -> (t * nat -> Type0) -> Type0
```
* {.fragment} **This can be *automatically derived* from the state monad transformer**
```
STATE.repr t = nat -> M (t * nat)
```
by selective **continuation-passing style (CPS)** returning `Type0`
  - `M` is the monad-argument of the monad transformer
  - it marks where the CPS-translation happens
  - type system (conservatively) restricts where the marker `M` can appear

* {.fragment} **This works well for large class of monadic effects:**\
  - state, exceptions, their combinations, continuations, etc.

* {.fragment} [**Summary:**]{color:DarkBlue} From a monadic effect definition we can derive a\
  **correct-by-construction weakest-precondition calculus** for this effect.

<!-- commented this out because of lack of time -->
<!-- TODO: take slides 8--12 and 14 from Guido's POPL talk -->

<!-- ## Formalization ## -->

<!-- * **Two calculi** -->
<!--   - DMF: simply-typed with an abstract base monad, and restricted;\ -->
<!--     used to **define** monads, actions, lifts -->
<!--   - EMF\*: dependently-typed, user-defined effects, reifying/reflecting -->

<!-- * {.fragment} **Two translations from well-typed DMF terms to EMF\*** -->
<!--   - `*`-translation: gives specification (selective CPS) -->
<!--   - elaboration: gives implementation (essentially an identity) -->

<!-- * {.fragment} **`*`-trans gives correct Dijkstra monad for elaborated terms** -->

<!-- ## Graphically ## -->

<!-- ~Center -->
<!-- ![dm4free] -->
<!-- ~ -->

<!-- [dm4free]: ../../stuff/dm4free.png { heigth=100% } -->


<!-- ## Correct reasoning about PURE ## -->

<!-- * `PURE` is the only primitive EMF\* effect (F\* also has `DIV`) -->

<!-- * {.fragment} A WP for `PURE` is of type  -->
<!--   ``` -->
<!--   PURE.wp t = (t -> Type0) -> Type0 -->
<!--   ``` -->
<!--     - Dijkstra monad for `PURE` is **exactly the continuation monad** -->

<!-- * {.fragment} **Total Correctness of `PURE`:**\ -->
<!--   If `⊢ e : PURE t wp` &nbsp;&nbsp;and&nbsp;&nbsp; `⊢ wp p` -->
<!--   &nbsp;&nbsp;then&nbsp;&nbsp; `e ↝* v` &nbsp;&nbsp;s.t.&nbsp;&nbsp; `⊨ p v` -->

<!-- ## Correct reasoning about STATE ## -->

<!-- * Say we have a term `e : nat -> t × nat` -->

<!-- * {.fragment} From logical relation, we get -->
<!--   - [e]{.under} : `s₀ : nat -> PURE (t × nat) (e* s₀)` -->

<!--   <\!-- Say this means it's a correct/valid Dijkstra monad -\-> -->

<!-- * {.fragment} From previous and correctness of `PURE`, we get\ -->
<!--   **Correctness of `STATE`**\ -->
<!--   If `⊢ e : nat -> t × nat` &nbsp;&nbsp;and&nbsp;&nbsp; ⊢ `e* s₀ p`\ -->
<!--   then&nbsp;&nbsp; [e]{.under} `s₀ ↝* (v,s)` -->
<!--   &nbsp;&nbsp;s.t.&nbsp;&nbsp; `⊨ p (v,s)` -->

<!-- ## Extra properties of the translations ## -->
<!-- <\!-- (Besides \* correctly specifying programs) -\-> -->
<!-- * **`*`-translation preserves equality** -->
<!--   - Monads mapped to Dijkstra monads -->
<!--   - Lifts mapped to Dijkstra lifts -->
<!--   - Laws about actions preserved -->

<!-- * {.fragment} `e*` is **monotonic**: maps weaker post's to weaker pre's -->
<!--   - `(∀x. p₁ ⇒ p₂) ⇒ e* p₁ ⇒ e* p₂` -->

<!-- * {.fragment} `e*` is **conjunctive**: distributes over ∧ and ∀ -->
<!--   - `e* (fun x -> p₁ x ∧ p₂ x) ⇔ e* p₁ ∧ e* p₂` -->

<!-- * {.fragment} so for any DMF monad we produce correct Dijkstra monad,\ -->
<!--   that's usable within the F\* verification system -->

<!------------------------------------------------------------------------------>

<!------------------------------------------------------------------------------>

## Verifying effectful programs extrinsically ##

<!-- <\!-----------------------------------------------------------------------------\-> -->

## Verifying effectful programs ##
### New way: extrinsically (by exposing pure monadic representation) ###

* {.fragment} [**Monadic reification**]{color:DarkBlue} (very much simplified)
  ```
  STATE.reify : (St a) -> (nat -> Tot (a * nat))
  ```

* {.fragment} [**Monadic reflection**]{color:DarkRed} takes us in the other direction
  ```
  STATE.reflect : (nat -> Tot (a * nat)) -> (St a)
  ```

* {.fragment} [**Reification**]{color:DarkBlue} allows us to give **weak specification** to a program
  ```
  let incr (r:ref nat) : St unit
    = r := !r + 1
  ```

* {.fragment} and give an **extrinsic proof** of its correctness
  ```
  let incr_works (r:ref nat) (h:heap)
  
    : Lemma (sel (snd (STATE.reify (incr r) h)) r = sel h r + 1)
    
    = ()
  ```

## Verifying effectful programs ctd. ##
### New way: extrinsically (by exposing pure monadic representation) ###

* or about **different runs** of the **same program**
  - {.fragment} for example, for proofs of non-interference
    ```
    let state = int * int                                         (* (high - low) values *)

    let st (a:Type) = state -> M (a * state)

    total reifiable reflectable new_effect {
      STATE : a:Type -> Effect
      with repr = st
         ; ...
    }

    ```

    ```
    let incr (n:int) : St unit 
      = STATE?.put_low (STATE?.get_low() + n)

    let incr2 () : St unit 
      = if (STATE?.get_high() = 42) then (incr 2)
                                    else (incr 1; incr 1)

    let non_interference ()
      : Lemma (forall h0 h1 n. let (_ , (h0' , n' )) = reify (incr2 ()) (h0,n) in 
                               let (_ , (h1' , n'')) = reify (incr2 ()) (h1,n) in n' = n'')
      = ()
    ```

* {.fragment} or even about **different runs** of **different programs**

<!-- <\!-- TODO: try out this code -\-> -->

<!-- <\!-- STATE.reify (e : ST a pre post) -\-> -->
<!-- <\!--   : n0:nat -> Pure (a * nat) (requires (pre n0)) -\-> -->
<!-- <\!--                              (ensures (fun r -> post n0 (fst r) (snd r)) -\-> -->


<!-- <\!-----------------------------------------------------------------------------\-> -->

## Reification works pretty well ##

* **Reducing effectful verification to pure verification**
  - for which F* already has good support (i.e. SMT automation)

* {.fragment} **Recent experiments using this for "relational verification"**
  - correctness of program transformations
  - information flow control
  - proofs of algorithmic optimizations (memoization, union-find)
  - simple game-based cryptographic proofs

* {.fragment} **Downside**: reification doesn't play well with monotonic state
  - meaning that one cannot safely reify the _real_ `STATE` and `Stack` effects



<!------------------------------------------------------------------------------>

## Tactics as a user-defined, non-primitive effect ##

<!------------------------------------------------------------------------------>

## Tactics (New, Still Experimental) ##

* F\* tactics written as **effectful F\* code** (inspired by Lean, Idris)

* have **access to F\*'s proof state** (and can efficiently roll it back)

* can **introspect on F\* terms** (deep embedding, simply typed)

* can be **[interpreted]{color:DarkRed}** by F\*'s normalizer or **[compiled to OCaml]{color:DarkGreen}**

* {.fragment} **user-defined, non-primitive effect**: proof state + exceptions monad

    ```
    noeq type __result a =
        | Success of a * proofstate
        | Failed  of string *   (* error message *)
                     proofstate (* the proofstate at time of failure *)

    let __tac (a:Type) = proofstate -> Tot (__result a)

    new_effect {
      TAC : a:Type -> Effect
      with repr     = __tac
           ...
    }

    let tactic (a:Type) = unit -> Tac a
    ```
<!------------------------------------------------------------------------------>

## Tactics can discharge verification conditions (replacing SMT) ##

~Center
![tactics-assert_by_tactic]
~
[tactics-assert_by_tactic]: ../../stuff/tactics-assert_by_tactic.png { heigth=50% }

<!------------------------------------------------------------------------------>


## Tactics can massage verification conditions (complementing SMT) ##

~Center
![tactics-canon]
~
[tactics-canon]: ../../stuff/tactics-canon.png { heigth=50% }

<!------------------------------------------------------------------------------>

## Tactics can synthesize F\* terms (metaprogramming) ##

~Center
![tactics-synth_by_tactic]
~
[tactics-synth_by_tactic]: ../../stuff/tactics-synth_by_tactic.png { heigth=50% }

<!------------------------------------------------------------------------------>

## Some uses of tactics ##

* **Reflective tactics for arithmetic** (proof automation)

* **Bitvectors in Vale** (proof automation)

* **Separation logic** (proof automation)

* **Pattern matcher** (metaprogramming)

* **Efficient low-level parsers and printers** (metaprogramming)

<!------------------------------------------------------------------------------>

## That's it ##

* Friday: A Gentle Introduction to F\* (Purely Functional Programs)

* Yesterday: Verifying Stateful Programs in F\*

* Today: Monotonic State in F\*

* Today: F\*'s Extensible Effect System and Metaprogramming in F\*

~Center
[![fstar-logo]](https://www.fstar-lang.org)
~
