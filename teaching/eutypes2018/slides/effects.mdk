[INCLUDE=presentation]
Title         : Program Verification with F*
Author        : Danek Ahman
Affiliation   : Inria Paris
Reveal Url    : ../reveal.js
Reveal Theme  : white
Colorizer     : ../../stuff/fstarlang
Logo          : False
Html Header   :
    <script src="../../stuff/script.js"></script>
    <link rel="stylesheet" href="../../stuff/style.css" id="custom_style">
Package       : xypic
~Pre,~Code: language=fstarlang

~ MathDefs
[INCLUDE=../../stuff/latex.tex]
~

# F\*'s Extensible Effect System<br/>and<br/>Metaprogramming in F\*  #

~Center
[![fstar-logo]](https://www.fstar-lang.org)

**[Danel Ahman, Inria Paris](https://danelahman.github.io/)**

[EUTypes Summer School](https://sites.google.com/view/2018eutypesschool/home/)

Ohrid, Macedonia, 12 August, 2018
~

[fstar-logo]: ../../stuff/fstar-new.png { width=200px }

<!-------------------------------------------------------------------------------->

## Schedule ##

* Friday: A Gentle Introduction to F\* (Purely Functional Programs)

* Yesterday: Verifying Stateful Programs in F\*

* Today: Monotonic State in F\*

* **Today: F\*'s Extensible Effect System and Metaprogramming in F\***

<!------------------------------------------------------------------------------>

## This talk ##

* **Monadic effects** in F\*

* **Tactics** and **Metaprogramming** as a user-defined, non-primitive effect

* **Under the hood:** Weakest preconditions (and Dijkstra monads)

<!-- * **Under the hood:** F* to SMT encoding -->

<!-- commented out because of lack of time -->
<!-- * **Verifying effectful programs extrinsically** (monadic reification) -->

<!------------------------------------------------------------------------------>

## Monadic effects in F\*: Global State ##

<!-- Effects defined using monads from total functions -->
```
type st (mem:Type) (a:Type) = mem -> Tot (a * mem)
```

~Fragment
```
total reifiable new_effect {
  STATE_m (mem:Type) : a:Type -> Effect
 
  with (* functional representation of the global state effect *)
       repr   = st mem;

       (* standard monadic return and bind for the state monad *)
       return = fun (a:Type) (x:a) (m:mem) -> (x, m);
       
       bind   = fun (a b:Type) (f:st mem a) (g:a -> st mem b) (m:mem) ->
                let (z, m') = f m in
                g z m';

       (* standard get and put actions for the state monad *)
       get    = fun () (m:mem) -> (m, m);
       
       put    = fun (m:mem) _ -> ((), m)
}
```
```
total reifiable new_effect STATE = STATE_m heap
```
~

* {.fragment} this monadic definition is the **model** F\*  uses to verify stateful code
* {.fragment} state can be **primitively implemented** under the hood, **or not**, e.g., 
  - by ML references,
  - or by C stack+heap

<!------------------------------------------------------------------------------>

## Monadic lifts in F*: State + Exceptions ##

```
let stexn a = nat -> Tot ((either a string) * nat))
```
~Fragment
```
new_effect {
  STEXN: a:Type -> Effect

  with (* functional representation of the sum of state and exceptions monads *)
       repr    = stexn;

       (* standard monadic return and bind *)
       return  = fun (a:Type) (x:a) s -> (Inl x, s);
       
       bind    = fun (a b:Type) (f:stexn a) (g:a -> stexn b) s0 ->
                    let (r,s1) = f s0 in
                    match r with
                    | Inl ret -> (Inl (g ret s1), s1)
                    | Inr m -> (Inr m, s1)

       (* action of raising excaptions *)
       raise   = fun (a:Type) (msg:string) s -> (Inr msg, s);
}
```
~
~Fragment
```
sub_effect STATE ~> STEXN {
  lift = fun (a:Type) (e:st nat a) ->
  
         fun s -> let (x,s') = e s in (Inl x, s')
}
```
~

<!------------------------------------------------------------------------------>

## Programming with effects, in direct style ##

* In F\*, the programmer writes:
  ```
  let incr () : STATE unit ...
    = let x = get() in
      put (x + 1);
      let y = get() in
      assert (y > x)
  ```

* {.fragment} Which is then made explicitly monadic via type and effect inference

  ```
  let incr () : STATE unit ...
    = STATE.bind (STATE.get ()) (fun x -> 
      STATE.bind (STATE.put (x + 1)) (fun _ ->
      STATE.bind (STATE.get ()) (fun y ->
      STATE.return (assert (y > x)))))
  ```

<!------------------------------------------------------------------------------>

## Programming with multiple effects, in direct style

* Programmer writes:
  ```
  ( / ) : int -> x:int{x<>0} -> Tot int
    
  let divide_by (x:int) : STEXN unit ...
    = if x <> 0 then put (get () / x)
                else raise "Divide by zero"
  ```

* {.fragment}Elaborated to:
  ```
  let divide_by x
    = if x <> 0 then STATE_STEXN.lift (STATE.bind (STATE.get()) (fun n ->
                                       STATE.put (n / x)))
                else STEXN.raise "Divide by zero"
  ```

* {.fragment}F\* infers the least effect of each sub-term
    - automatically lifts computations to use the suitable effect
    - ensures that reasoning isn't needlessly polluted by unused effects

<!------------------------------------------------------------------------------>

<!-- ## Verifying effectful programs extrinsically ## -->

<!-- <\!-----------------------------------------------------------------------------\-> -->

<!-- ## Verifying effectful programs ## {#effect2} -->
<!-- ### New way: extrinsically (by exposing pure monadic representation) ### -->

<!-- * {.fragment} Monadic reification (intuitively) -->
<!--     ``` -->
<!--     STATE.reify : (St a) -> Ghost (nat -> Tot (a * nat)) -->
<!--     ``` -->

<!-- <\!-- reify only when the abstraction permits (e.g. ghost code) -\-> -->

<!-- * {.fragment} Allows us to give **weak specification** to an effectful function -->
<!--   ``` -->
<!--     let incr (r:ref nat) : St unit = (r := (!r + 1)) -->
<!--   ``` -->

<!-- * {.fragment} and **prove lemmas about reification** of effectful computation -->
<!--   ``` -->
<!--     let incr_works (r:ref nat) (h:heap) : -->
<!--       Lemma (sel (snd (STATE.reify (incr r) h)) r = sel h r + 1) = () -->
<!--   ``` -->

<!-- <\!-- TODO: try out this code -\-> -->

<!-- <\!-- STATE.reify (e : ST a pre post) -\-> -->
<!-- <\!--   : n0:nat -> Pure (a * nat) (requires (pre n0)) -\-> -->
<!-- <\!--                              (ensures (fun r -> post n0 (fst r) (snd r)) -\-> -->

<!-- <\!-----------------------------------------------------------------------------\-> -->

<!-- ## Reification works very well ## -->

<!-- * **Reducing effectful verification to pure verification** -->
<!--     - for which F* already has good support (i.e. SMT automation) -->

<!-- * **Recent experiments using this for "relational verification"** -->
<!--     - Correctness of program transformations -->
<!--     - Information flow control -->
<!--     - Proofs of algorithmic optimizations (memoization, union-find) -->
<!--     - Simple game-based cryptographic proofs -->

<!------------------------------------------------------------------------------>

## Tactics as a user-defined, non-primitive effect ##

<!------------------------------------------------------------------------------>

## Tactics (New, Still Experimental) ##

* F\* tactics written as **effectful F\* code** (inspired by Lean, Idris)

* have **access to F\*'s proof state** (and can efficiently roll it back)

* can **introspect on F\* terms** (deep embedding, simply typed)

* can be **[interpreted]{color:DarkRed}** by F\*'s normalizer or **[compiled to OCaml]{color:DarkGreen}**

* {.fragment} **user-defined, non-primitive effect**: proof state + exceptions monad

    ```
    noeq type __result a =
        | Success of a * proofstate
        | Failed  of string *   (* error message *)
                     proofstate (* the proofstate at time of failure *)

    let __tac (a:Type) = proofstate -> Tot (__result a)

    new_effect {
      TAC : a:Type -> Effect
      with repr     = __tac
           ...
    }

    let tactic (a:Type) = unit -> Tac a
    ```

<!------------------------------------------------------------------------------>

## Tactics can discharge verification conditions (replacing SMT) ##

~Center
![tactics-assert_by_tactic]
~
[tactics-assert_by_tactic]: ../../stuff/tactics-assert_by_tactic.png { heigth=50% }

<!------------------------------------------------------------------------------>


## Tactics can massage verification conditions (complementing SMT) ##

~Center
![tactics-canon]
~
[tactics-canon]: ../../stuff/tactics-canon.png { heigth=50% }

<!------------------------------------------------------------------------------>

## Tactics can synthesize F\* terms (metaprogramming) ##

~Center
![tactics-synth_by_tactic]
~
[tactics-synth_by_tactic]: ../../stuff/tactics-synth_by_tactic.png { heigth=50% }

<!------------------------------------------------------------------------------>

## Some uses of tactics ##

* **Reflective tactics for arithmetic** (proof automation)

* **Bitvectors in Vale** (proof automation)

* **Separation logic** (proof automation)

* **Pattern matcher** (metaprogramming)

* **Efficient low-level parsers and printers** (metaprogramming)


<!------------------------------------------------------------------------------>

## Under the hood ##

### Weakest preconditions (Dijkstra monads for free) ###

<!-- ### SMT encoding ### -->

<!------------------------------------------------------------------------------>

## Computation types indexed by predicate transformers ##

Pre- and postconditions are just syntactic sugar:
```
Pure t (pre : Type0) (post : t->Type0)
  = PURE t (fun k -> pre /\ forall y. post y ==> k y)       (* where k is the         *)
                                                            (* "logical" continuation *)
```
```
val factorial : x:int -> Pure int (requires (x >= 0))
                                  (ensures  (fun y -> y >= 0))
```
```
val factorial : x:int -> Pure (fun k -> x >= 0 /\ forall y. y >= 0 ==> k y)
```
~Fragment
Same for user-defined effects, like `STATE`:
```
ST t (pre : nat -> Type0) (post : nat -> t -> nat -> Type0) 
  = STATE t (fun n0 k -> pre n0 /\ forall x n1. post n0 x n1 ==> k x n1)
```
```
val incr : unit -> St unit (requires (fun n0 -> True))
                           (ensures  (fun n0 _ n1 -> n1 = n0 + 1))
```
```
val incr : unit -> STATE unit (fun n0 k -> k () (n0 + 1))
```
~

## Computing weakest preconditions, by example ##
```
let incr () = STATE.bind (STATE.get()) (fun x ->
              STATE.put (x + 1))
```
* {.fragment} By inferring type for `incr` against following interface:
  ```
  STATE.get : unit -> STATE nat (STATE.get_wp ())
  
  STATE.put : n:nat -> STATE unit (STATE.put_wp n)
  
  STATE.bind : STATE 'a 'wa ->
               (x:'a -> STATE 'b ('wb x)) ->
               STATE 'b (STATE.bind_wp 'wa 'wb)
  ```
... we compute the weakest precondition for `incr`
  ```
  val incr : unit -> STATE unit (STATE.bind_wp (STATE.get_wp()) (fun x ->
                                 STATE.put_wp (x + 1)))
  ```
  ```
  = (fun n0 k -> k () (n0 + 1)) 
  ```
* {.fragment} **Generic way of computing weakest-preconditions for all effects**
  - provided we have a monad structure on predicate transformers
  - instance of a more general notion of monad-indexed monad structures

## Predicate transformers monad for state ## 

### aka a Dijkstra monad for state ###

```
let STATE.wp t = (t -> nat -> Type0) -> (nat -> Type0)

val STATE.return_wp : 'a -> Tot (STATE.wp 'a)

val STATE.bind_wp : (STATE.wp 'a) ->
                    ('a -> Tot (STATE.wp 'b)) ->
                    Tot (STATE.wp 'b)
                      
val STATE.get_wp : unit -> Tot (STATE.wp nat)
val STATE.put_wp : nat -> Tot (STATE.wp unit)
```
* whose implementation is given by:
```
let STATE.return_wp v = fun p -> p v
let STATE.bind_wp wp f = fun p -> wp (fun v -> f v p)
let STATE.get_wp () = fun p n0 -> p n0 n0
let STATE.put_wp n = fun p _ -> p () n
```
* and for a while we wrote such things by hand;\

* but this is **quite tricky** and comes with **strong proof obligations**\
  (correctness with respect to effect definition, monad laws, ...)

## Dijkstra monads for free ## {#dm4f}

```
STATE.wp t  = (t -> nat -> Type0) -> (nat -> Type0)

           ~= nat -> (t * nat -> Type0) -> Type0
```
* {.fragment} **This can be *automatically derived* from the state monad transformer**
```
STATE.repr t = nat -> M (t * nat)
```
by selective **continuation-passing style (CPS)** returning `Type0`
  - `M` is the monad-argument of the monad transformer
  - it marks where the CPS-translation happens
  - type system (conservatively) restricts where the marker `M` can appear

* {.fragment} **This works well for large class of monadic effects:**\
state, exceptions, their combinations, continuations, etc.

* {.fragment} Summary: From a monadic effect definition we can derive a\
  **correct-by-construction weakest-precondition calculus** for this effect.

<!-- commented this out because of lack of time -->
<!-- TODO: take slides 8--12 and 14 from Guido's POPL talk -->

<!-- ## Formalization ## -->

<!-- * **Two calculi** -->
<!--   - DMF: simply-typed with an abstract base monad, and restricted;\ -->
<!--     used to **define** monads, actions, lifts -->
<!--   - EMF\*: dependently-typed, user-defined effects, reifying/reflecting -->

<!-- * {.fragment} **Two translations from well-typed DMF terms to EMF\*** -->
<!--   - `*`-translation: gives specification (selective CPS) -->
<!--   - elaboration: gives implementation (essentially an identity) -->

<!-- * {.fragment} **`*`-trans gives correct Dijkstra monad for elaborated terms** -->

<!-- ## Graphically ## -->

<!-- ~Center -->
<!-- ![dm4free] -->
<!-- ~ -->

<!-- [dm4free]: ../../stuff/dm4free.png { heigth=100% } -->


<!-- ## Correct reasoning about PURE ## -->

<!-- * `PURE` is the only primitive EMF\* effect (F\* also has `DIV`) -->

<!-- * {.fragment} A WP for `PURE` is of type  -->
<!--   ``` -->
<!--   PURE.wp t = (t -> Type0) -> Type0 -->
<!--   ``` -->
<!--     - Dijkstra monad for `PURE` is **exactly the continuation monad** -->

<!-- * {.fragment} **Total Correctness of `PURE`:**\ -->
<!--   If `⊢ e : PURE t wp` &nbsp;&nbsp;and&nbsp;&nbsp; `⊢ wp p` -->
<!--   &nbsp;&nbsp;then&nbsp;&nbsp; `e ↝* v` &nbsp;&nbsp;s.t.&nbsp;&nbsp; `⊨ p v` -->

<!-- ## Correct reasoning about STATE ## -->

<!-- * Say we have a term `e : nat -> t × nat` -->

<!-- * {.fragment} From logical relation, we get -->
<!--   - [e]{.under} : `s₀ : nat -> PURE (t × nat) (e* s₀)` -->

<!--   <\!-- Say this means it's a correct/valid Dijkstra monad -\-> -->

<!-- * {.fragment} From previous and correctness of `PURE`, we get\ -->
<!--   **Correctness of `STATE`**\ -->
<!--   If `⊢ e : nat -> t × nat` &nbsp;&nbsp;and&nbsp;&nbsp; ⊢ `e* s₀ p`\ -->
<!--   then&nbsp;&nbsp; [e]{.under} `s₀ ↝* (v,s)` -->
<!--   &nbsp;&nbsp;s.t.&nbsp;&nbsp; `⊨ p (v,s)` -->

<!-- ## Extra properties of the translations ## -->
<!-- <\!-- (Besides \* correctly specifying programs) -\-> -->
<!-- * **`*`-translation preserves equality** -->
<!--   - Monads mapped to Dijkstra monads -->
<!--   - Lifts mapped to Dijkstra lifts -->
<!--   - Laws about actions preserved -->

<!-- * {.fragment} `e*` is **monotonic**: maps weaker post's to weaker pre's -->
<!--   - `(∀x. p₁ ⇒ p₂) ⇒ e* p₁ ⇒ e* p₂` -->

<!-- * {.fragment} `e*` is **conjunctive**: distributes over ∧ and ∀ -->
<!--   - `e* (fun x -> p₁ x ∧ p₂ x) ⇔ e* p₁ ∧ e* p₂` -->

<!-- * {.fragment} so for any DMF monad we produce correct Dijkstra monad,\ -->
<!--   that's usable within the F\* verification system -->

<!------------------------------------------------------------------------------>

# From F\* to SMT # {#fstar2smt}

<!------------------------------------------------------------------------------>

## SMT encoding ## {#smtencoding}

- F* verification conditions
  + **classical, dependently typed, higher-order logic**

- {.fragment}We encode this to SMT
  + **FOL + equality and function symbols + arithmetic + e-matching **
  + goals: **soundness**, **predictability**, **efficiency**, **scalability**
  + pragmatic balance between **completeness** and **practical tractability**

- {.fragment}The encoding
  + **preserves types**
  + combines a **deep and a shallow embedding** of F* terms
  + allows **bounded unrolling** of recursive and inductive definitions
  + eliminates first-class functions by **lambda lifting**
  + uses **SMT-patterns** extensively to guide instantiation of quantifiers
  + currently targets only Z3 (but some early experiments with CVC4)

<!------------------------------------------------------------------------------>

## Encoding primitive operations and types ##

* [Primitive types]{color=Black;} (booleans, integers...) are boxed

  ```smt
  (declare-sort Term)

  (declare-fun BoxInt (Int) Term)
  (declare-fun BoxInt_proj (Term) Int)
  (assert (forall ((@x Int)) (= (BoxInt_proj (BoxInt @x)) @x))) 
 
  (declare-fun Prims.int () Type)
  (assert (forall ((@x Int)) (HasType (BoxInt @x) Prims.int))))
  ```
  
  Operators are given shallow semantics: 
  ```smt
   (assert (forall ((@x Term) (@y Term))
     (= (op_Subtraction @x @y) (BoxInt (- (BoxInt_proj @x) (BoxInt_proj @y))))))
   ```

<!------------------------------------------------------------------------------>

## Typechecking factorial ##
```
type nat = x:int{x>=0}
let rec factorial (n:nat) : nat = if n = 0 then 1 else n * (factorial (n - 1))
```
* {.fragment}Encoding type `nat`:
```smt
(assert (forall ((@x Term))
  (iff (HasType @x nat) (and (HasType @x int) (>= (BoxInt_proj @x) 0)))))
```
* {.fragment}Proving termination:
```smt
(declare-fun n () Term)
(assert (not (implies (and (HasType n nat) (not (= n (BoxInt 0))))
                      (Valid (Precedes (op_Subtraction n (BoxInt 1)) n)))))
```
* {.fragment}Can be proved because of this axiom:
```smt
(assert (forall ((@x Term) (@y Term))
           (implies (and (HasType @x nat) (HasType @y nat)
                         (< (BoxInt_proj @x) (BoxInt_proj @y)))
                    (Valid (Precedes @x @y)))))
```

<!------------------------------------------------------------------------------>

## Typechecking factorial (2) ##
```
type nat = x:int{x>=0}
let rec factorial (n:nat) : nat = if n = 0 then 1 else n * (factorial (n - 1))
```
* {.fragment}Return value is `nat`
```smt
(declare-fun n () Term)
(assert (HasType n nat))
(assert (forall ((@x Term))
                (implies (and (HasType @x nat) (Valid (Precedes @x n)))
                         (HasType (factorial @x) nat))))
```
```smt
(assert (not (ite (BoxBool_proj (op_Equality int n (BoxInt 0)))
                  (>= 1 0)
                  (>= (BoxInt_proj (op_Multiply n
                        (factorial (op_Subtraction n (BoxInt 1))))) 0 ))))
```

<!------------------------------------------------------------------------------>

## Allowing SMT solver to do bounded unrolling ##
```
type nat = x:int{x>=0}
let rec factorial (n:nat) : nat = if n = 0 then 1 else n * (factorial (n - 1))
```
```smt
(declare-datatypes () ((Fuel (ZFuel) (SFuel (prec Fuel)))))
(declare-fun MaxFuel () Fuel)
(assert (= MaxFuel (SFuel (SFuel ZFuel))))
```
~Fragment
```smt
(assert (forall ((@f Fuel) (x Term))
        (implies (HasType x nat)
                 (= (factorial_fuel (SFuel @f) x)
                    (ite (op_Equality int x (BoxInt 0))
                         (BoxInt 1)
                         (op_Multiply x
                                (factorial_fuel @f
                                     (op_Subtraction x (BoxInt 1)))))))))
```
~
~Fragment
```smt
(assert (forall ((@x Term)) (= (factorial @x) (factorial_fuel MaxFuel @x))))
```
~

<!------------------------------------------------------------------------------>

## Some dreams and ongoing work on F\* ##

* **[Improve tactics]{color:DarkBlue;}**, balance automation and control

* {.fragment} **[Better treatment of effects]{color:DarkBlue;}**:
  Dijkstra monads for free v2

* {.fragment} **[Studying more effects]{color:DarkBlue;}**:
  probabilities, concurrency, ...

* {.fragment} **[Effect masking]{color:DarkBlue;}**:
  hiding exceptions, state, divergence(!?), ...

* {.fragment} **[Further work out metatheory]{color:DarkBlue;}**
  and **[self-certify core type-checker]{color:DarkBlue;}**
  - **monadic reification + monotonic state** and **relation to modal logic**
  - soundly allowing **subtyping for datatypes** (`list nat <: list int`)

* {.fragment} **[Join the team at Inria Paris + Microsoft Research]{color:DarkRed;}**

<!-- * {.fragment} **[Verified interoperability]{color:DarkBlue;}**: F\* (OCaml) + Low\* (C) + Vale (ASM)  -->

<!-- TODO: have new look at my list of problems -->
